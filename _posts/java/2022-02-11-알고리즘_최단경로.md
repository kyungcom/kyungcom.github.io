---
title: "알고리즘-최단경로"
excerpt: "최단경로 알고리즘 대해서 알아보자"
last_modified_at: 2022-02-11T15:03:16-19:00
categories:
  - Java
tags:
  - Java
  - Algorithm
toc: true
toc_sticky: true
toc_label: "최단경로"
---

## 다익스트라 알고리즘

- 특정 노드에서 출발하여 다른 노드로 가는 각각의 최단 경로를 구해주는 알고리즘
1. 출발 노드를 설정합니다.
2. 최단 거리 테이블을 초기화합니다.
3. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택합니다.
4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신합니다.
5. 위 과정에서 3번과 4번을 반복합니다.

<br>

## 구현

### 방법1 - 간단한 다익스트라 알고리즘

- 단계마다 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택하기 위해 매 단계마다 1차원 리스트의 모든 원소를 확인

```java
import java.util.*;

class Branch{
        private int node;
        private int distance;

        public Branch(int node, int distance) {
                this.node = node;
                this.distance = distance;
        }

        public int getNode() {
                return node;
        }

        public void setNode(int node) {
                this.node = node;
        }

        public int getDistance() {
                return distance;
        }

        public void setDistance(int distance) {
                this.distance = distance;
        }
}

public class Change{

        public static final int INF = (int) 1e9;

        public static ArrayList<ArrayList<Branch>> branches = new ArrayList<ArrayList<Branch>>();

        public static int getSmallestNode(int[] distance, int[] visited) {
                int min = INF;
                int result = 0 ;
                for(int i = 1; i < distance.length; i++){
                        if(min > distance[i] && visited[i] == 0){
                                min = distance[i];
                                result = i;
                        }
                }

                return result;

        }

        public static void dijkstra(int start, int[] distance, int[] visited){
                distance[start] = 0;
                visited[start] = 1;
                for (int j = 0; j < branches.get(start).size(); j++) {
                        distance[branches.get(start).get(j).getNode()] = branches.get(start).get(j).getDistance();
                }

                for (int i = 0; i < distance.length-2; i++) {
                        int now = getSmallestNode(distance, visited);
                        visited[now] = 1;
                        for (int j = 0; j < branches.get(now).size(); j++) {
                                int cost = distance[now] + branches.get(now).get(j).getDistance();
                                if (cost < distance[branches.get(now).get(j).getNode()]) {
                                        distance[branches.get(now).get(j).getNode()] = cost;
                                }
                        }
                }
        }

        public static void main(String[] args){

                Scanner sc = new Scanner(System.in);

                int n = sc.nextInt();
                int m = sc.nextInt();
                int start = sc.nextInt();
                int[] visited = new int[n+1];
                int[] distance = new int[n+1];

                Arrays.fill(distance, INF);

                for (int i = 0; i <= n; i++) {
                        branches.add(new ArrayList<Branch>());
                }

                for(int i = 1; i < m+1; i++){
                        int a = sc.nextInt();
                        int b = sc.nextInt();
                        int c = sc.nextInt();

                        branches.get(a).add(new Branch(b, c));
                }

                dijkstra(start, distance, visited);
                for (int i = 1; i <= n; i++) {
                        if (distance[i] == INF) {
                                System.out.println("INFINITY");
                        }
                        else {
                                System.out.println(distance[i]);
                        }
                }

        }
}

```
해설: Branch정보를 저장하기위해 class로 만들어주었고, 앞서 설명한 방법대로 진행한 것을 코드로 볼 수 있습니다. start나 distance[], visited[] 를 파라미터로 넘겨주는 것이 마음에 들지 않는다면 전역변수로 빼는 방법도 있을 것 같네요.<br>
시간복잡도: 매번 최단거리 노드를 찾아야하고 그 노드에 연결된 노드를 확인해야하므로 O(V<sup>2</sup>)
<br>
<br>

### 방법2 - 개선된 다익스트라 알고리즘

- 우선순위 큐를 사용하여 최단거리 노드를 탐색하는 방법을 추가합니다.

```java
import java.util.*;

class Branch implements Comparable<Branch>{
        private int node;
        private int distance;

        public Branch(int node, int distance) {
                this.node = node;
                this.distance = distance;
        }

        public int getNode() {
                return node;
        }

        public void setNode(int node) {
                this.node = node;
        }

        public int getDistance() {
                return distance;
        }

        public void setDistance(int distance) {
                this.distance = distance;
        }

        @Override
        public int compareTo(Branch other) {
                if (this.distance < other.distance) {
                        return -1;
                }
                return 1;
        }
}

public class Change{

        public static final int INF = (int) 1e9;

        public static ArrayList<ArrayList<Branch>> branches = new ArrayList<ArrayList<Branch>>();

        public static int getSmallestNode(int[] distance, int[] visited) {
                int min = INF;
                int result = 0 ;
                for(int i = 1; i < distance.length; i++){
                        if(min > distance[i] && visited[i] == 0){
                                min = distance[i];
                                result = i;
                        }
                }

                return result;

        }

        public static void dijkstra(int start, int[] distance, int[] visited){
                PriorityQueue<Branch> pq = new PriorityQueue<>();
                pq.offer(new Branch(start, 0));
                distance[start] = 0;
                while(!pq.isEmpty()) {
                        Branch branch = pq.poll();
                        int dist = branch.getDistance();
                        int now = branch.getNode();
                        if (distance[now] < dist) continue;
                        for (int i = 0; i < branches.get(now).size(); i++) {
                                int cost = distance[now] + branches.get(now).get(i).getDistance();
                                if (cost < distance[branches.get(now).get(i).getNode()]) {
                                        distance[branches.get(now).get(i).getNode()] = cost;
                                        pq.offer(new Branch(branches.get(now).get(i).getNode(), cost));
                                }
                        }
                }
        }

        public static void main(String[] args){

                Scanner sc = new Scanner(System.in);

                int n = sc.nextInt();
                int m = sc.nextInt();
                int start = sc.nextInt();
                int[] visited = new int[n+1];
                int[] distance = new int[n+1];

                Arrays.fill(distance, INF);

                for (int i = 0; i <= n; i++) {
                        branches.add(new ArrayList<Branch>());
                }

                for(int i = 1; i < m+1; i++){
                        int a = sc.nextInt();
                        int b = sc.nextInt();
                        int c = sc.nextInt();

                        branches.get(a).add(new Branch(b, c));
                }

                dijkstra(start, distance, visited);
                for (int i = 1; i <= n; i++) {
                        if (distance[i] == INF) {
                                System.out.println("INFINITY");
                        }
                        else {
                                System.out.println(distance[i]);
                        }
                }

        }
}

```
<br><br>

## 참고문헌

![image](https://user-images.githubusercontent.com/72953874/152631668-d866cf48-9112-4366-ab8f-ff2123f46f56.png)

저자 나동빈 | 한빛미디어 | 2020.08.05
페이지 604 | ISBN 9791162243077