---
title: "스프링 입문을 위한 자바 객체지향의 이해"
excerpt: "스프링 입문을 위한 지식"
last_modified_at: 2022-03-24T18:03:16-19:00
categories:
  - Spring
tags:
  - Spring
  - Java
  - Object Oriented Programming
toc: true
toc_sticky: true
toc_label: "스프링 입문을 위한 지식"
---

## 객체지향 프로그래밍 언어의 등장

프로그래밍 언어의 발전 과정을 순서대로 크게 살펴보며, 객체지향 프로그래밍 언어가 왜 등장했는지 알아봅시다.

- 기계어 <br>

  0과 1로 이루어진 진공관을 이용한 프로그램

  <br>

- 어셈블리어

  기계어 명령어와 일상 용어를 일대일로 매칭하는 코드표(어셈블리)를 작성

  cpu마다 기계어가 다르기때문에 어셈블리어도 달랐다. 예를들어 어떤 어셈블리어는 덧셈은 PLUS였지만, 다른 어셈블리어에서는 덧셈이 ADD였습니다.<br>

  장점: 일상용어로 프로그램을 작성할 수 있습니다. <br>
  단점: 다른 종류의 cpu를 가진 시스템에서 프로그래밍하기 위해서는 다른 어셈블리어를 또 학습해야합니다.
  <br>


- c언어

  c언어는 위에 어셈블리어에서 말했던 단점인 하드웨어 별 사용언어가 다르다는 점을 보완했습니다.<br>
  하나의 소스파일로 맥용 os에서도 윈도우os에서도 사용할 수 있게 되었습니다. 단, 목적파일은 해당 시스템에 맞게 컴파일돼야합니다.<br>
  하지만, 운영체제에 따라서 short와 long의 크기 등 다른 부분이 있었기 때문에 그 기종에 맞게 소스를 변경하는 작업은 필요합니다. 
  <br>

  장점: 하나의 언어로 여러 시스템에서 사용 가능.<br>
  단점: 운영체제마다 다른 특성이 있어 그 특성에 맞게 수정해야함.<br>


- 자바

  가상머신을 사용하여 어느 시스템에서든 하나의 소스파일과, 하나의 목적파일로 실행이 가능합니다. 즉, 시스템에 맞는 컴파일러들이 필요한게 아닌, 가상머신에서 사용할 컴파일러 한 개만 있으면 됩니다.
  <br>

| | 어셈블리어 | c | 자바 |
|---|---|---|---|
|개발자의 코딩| 일상 단어 사용 | 수학적 기호 사용 | 수학적 기호 사용|
|소스 파일|기종마다 하나씩| 기종이 몇 개든 단 하나| 기종이 몇 개든 단 하나|
|목적 파일| 어셈블러로 기계어 생성| 컴파일러로 해당 운영체제용 기계어 생성|기종이 몇 개든 단 하나의 JVM용 기계어 생성|
 

## 자바와 절차적/구조적 프로그래밍

### JVM에 대한 이해

- JDK (자바 개발 도구)
- JRE (자바 실행 환경)
- JVM (자바 가상 기계)

JDK가 JRE를 포함하고 JRE가 JVM을 포함하는 방식입니다.


<br>

### 절차적/구조적 프로그래밍

절차적 프로그래밍을 한마디로 표현하면 goto를 사용하지 말라는 것. <br>
구조적 프로그래밍을 한마디로 표현하면 함수를 쓰라는 것.<br>
<br>


### 자바의 데이터 영역 메모리 사용


![image](https://user-images.githubusercontent.com/72953874/160244299-19479e53-235d-4479-8662-8cf0e5342495.png)

자바의 데이터 영역 메모리는 위 그림과 같이 3구역으로 나뉩니다.<br>

```java
public class Start{
  public static void main(String[] args){
    System.out.println("안녕하세요");
  }
}
```

위와 같은 코드가 실행될 때 메모리가 어떻게 사용되는지 알아봅시다.<br>

1. JRE가 main()메서드가 있는지 확인
2. 있다면 JVM을 실행
3. JVM은 아래(4, 5번)와 같은 전처리 작업을 수행
4. JVM은 java.lang 패키지를 스태틱 영역에 가져다 놓음
5. import 패키지들과 개발자가 작성한 클래스들을(사용할 때) 스태틱 영역에 가져다 놓는다.(<strong>여기까지가 전처리</strong>)
6. main()메서드를 위한 스택프레임이 스택 영역에 할당된다.(이는 중괄호를 만날 때마다 생긴다고 생각하면 된다.)
7. 메서드의 인자 args를 저장할 변수공간을 스택 프레임의 맨 밑에 확보한다.
8. 명령문을 실행하고 닫는 중괄호를 만나면 스택 프레임이 소멸된다.
9. main()메서드가 끝나면 JRE가 JVM을 종료하고 JRE자체도 운영체제에서 사라진다.

<br>

- 유의사항들

만약 main메서드 안에 if같이 중괄호가 필요한 연산들이 등장하면 메인 메서드 안에 if를 위한 스택 프레임이 생기는 방식입니다. <br>
<strong>외부 스택 프레임에서 내부 스택 프레임의 변수에 접근하는 것은 불가능하나 그 역은 가능합니다.</strong><br>

동일 수준 스택 프레임도 서로 접근 불가능합니다.<br>

전역변수는 스태틱 영역에 변수 공간에 할당됩니다.

<br><br>

### 멀티 스레드 / 멀티 프로세스의 이해

#### 멀티 스레드

- 스택 영역을 스레드 개수만큼 분할해서 쓰는 것


#### 멀티 프로세스

- 다수의 T메모리(데이터 저장 영역 메모리)를 갖는 구조

<br>

## 객체지향의 4대 특성

1. 캡슐화: 정보 은닉
2. 상속: 재사용
3. 추상화: 모델링
4. 다형성: 사용 편의

### 객체와 클래스 구분

객체: 세상에 존재하는 유일무이한 사물 <br>
클래스: 분류, 집합. 같은 속성과 기능을 가진 객체를 총칭하는 개념<br>
예시: 사람:박인호 = 강아지:뽀삐(옆집 강아지)<br>
<br>


### 추상화

<strong>추상화</strong>란 구체적인 것을 분해해서 관심영역에 있는 특성만 가지고 재조합하는 것이다. == 모델링입니다. <br>

<br>
예를들어 병원 환자관리 앱을 만든다면 그 앱 내의 사람은 환자일 것이므로 환자의 특성만을 고려하여 모델링하면 됩니다.

<br><br>

#### java에서의 추상화

자바에서는 추상화를 class로 지원합니다.<br>

```java
클래스 객체_참조_변수 = new 클래스();
```

앞서 이야기 했던 것 처럼 클래스들은 사용시에 메모리의 스태틱 영역에 생성됩니다. 이때, 클래스 인스턴스 멤버변수에는 공간을 할당하지 않고, static 멤버변수에만 공간을 할당하여 모든 객체가 값을 공유하게 합니다. 그 후, 객체를 생성하면 객체는 T메모리의 힙 영역에 생성되며, 객체_참조_변수는 객체의 주소를 갖고 있게됩니다. 이는 정적 메서드와 인스턴스 메서드에도 마찬가지로 적용됩니다. <br><br>

위의 이유로 맨처음에는 어떤 인스턴스도 생성되지 않았기 때문에 main() 메서드는 static으로 선언되는 것 입니다.

<br><br>


### 상속: 재사용 + 확장

- 상속이란 클래스의 특성을 하위 클래스에서 상속하고 확장해서 사용할 수 있다는 의미입니다. 
- 상위 클래스 쪽으로 갈수록 추상화, 일반화 되었다고 말하며 하위클래스로 갈수록 구체와, 특수화 됐다고 말합니다.
- 하위 클래스는 상위 클래스입니다.(포유류(하위 클래스)는 동물(상위 클래스)입니다.)
- 객체지향의 상속은 is a kind of 관계를 만족해야 합니다.

<br><br>

#### 상속과 인터페이스

- 인터페이스: 구현 클래스 is able to 인터페이스
- public 추상 메서드와 public 정적 상수만 가질 수 있습니다.

클래스에 구현해야하는 메서드를 지정하는 것입니다.<br><br> 

### 다형성

- 오버로딩 = 같은 메서드 이름. 다른 인자 목록으로 다수의 메서드를 중복 정의
- 오버라이딩 = 같은 메서드 이름, 같은 인자 목록으로 상위 클래스의 메서드를 정의
<br>

### 캡슐화: 정보은닉

- public : 모두가 접근 가능
- protected : 상속 / 같은 패키지 내의 클래스에서 접근 가능
- default : 아무런 접근 제한자를 명시하지 않으면 default 값이 되며, 동일한 패키지 내에서만 접근이 가능
- private : 자기 자신의 클래스 내에서만 접근이 가능


## 자바가 확장한 객체지향

### 추상클래스, 추상메서드

- 선언부는 있지만 구현부가 없는 메서드 = 추상메서드
- 추상메서드를 하나라도 갖고 있는 클래스 = 추상 클래스

```java
public abstract class 동물{
  abstract void 울어보세요();
} 
```

- 상속한 하위클래스가 추상메서드를 구현해야만 합니다.

<br>

### static 블록
- 클래스가 스태틱 영역에 배치될 때 실행되는 코드
- static블록에서 사용 가능한 속성과 메서드는 static 멤버 뿐입니다.
- 클래스가 처음 사용될 때 클래스들의 정보를 static영역에 넣습니다.

<br>

### final 키워드

- final 클래스 = 상속 불가능
- final 메서드 = 오버라이딩 불가능
- final 변수 = 정적 상수

<br>

## 객체 지향 설계 5원칙 SOLID

### SRP(Single Responsibility Principle): 단일 책임 원칙

말 그대로 하나의 책임을 진다는 소리입니다. <br>
예를들어
```java

class 강아지 {
  Boolean 성별;

  void 소변보다() {
    if (this.성별 == true){
      //한쪽 다리를 들고 소변을 본다 (수컷)
    }else {
      //뒷다리 두 개를 굽혀앉은 자세로 소변을 본다.(암컷)
    }
  }
}
```
위 같은 경우 하나의 클래스가 수컷, 암컷을 모두 구현하려고 합니다. 이런 경우가 SRP를 위배한 것입니다.<br>
이를 바꿔 수컷강아지와 암컷강아지로 클래스를 각각 구성한다면 SRP를 지키게 되는 것입니다.<br><br>

### OCP(Open Closed Principle): 개방 폐쇄 원칙

- 자신의 확장에는 열려있고, 주변의 변화에 대해서는 닫혀 있어야 합니다.

예시 몇가지

1. 운전자의 차량변경
2. 손님에게 물건을 판매하는 판매직원의 변경(편의점 사장, 청소 담당직원, 보안 담당직원)

첫번째에는 차량 인터페이스에 차량에 필요한 기능을 넣어두면, 차량의 변경 즉, 자신의 확장에는 열려있지만 운전자가 해야할 것은 변하지 않습니다. 주변의 변화에는 닫혀있게 됩니다.<br>

두번째에는 판매 인터페이스에 직원들을 변경해서 넣으면, 판매행위에 청소기능, 보안기능 등이 추가되어 자신의 확장에는 열려있지만, 손님에게 물건을 판매하는 기능은 모두 있으므로 손님 입장에서는 달라질 것이 없습니다. 따라서 주변의 변화에는 닫혀있게됩니다.<br><br>


### LSP(Liskov Substitution Principle): 리스코프 치환 원칙

- 서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야한다.
- 하위 클래스 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는 데 문제가 없어야 한다.

다음 두가지를 만족하면 LSP를 만족하고 있다고 할 수 있습니다.
1. 하위 클래스 is a kind of 상위 클래스
2. 구현 클래스 is able to 인터페이스
<br><br>

### ISP(Interface Segregation Principle): 인터페이스 분리 원칙

- 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다.

SRP와는 다르게 각각의 클래스로 만드는 것이 아닌 상속을 이용한 방식.<br>
예를들어 남자 클래스를 상속받아 군인, 남자친구, 아들 인터페이스로 만드는 것입니다.<br><br>

### DIP(Dependency Inversion Principle): 의존 역전 원칙

- 자주 변경되는 구체 클래스에 의존하지 말 것.
- 구체적인 것이 추상화된 것에 의존해야 함.

예를들어 자동차의 타이어는 종류가 변할 수 있으니 자동차는 타이어 인터페이스에만 의존하도록 합니다.
<br><br>

이론적으로 필요한 내용은 여기까지입니다.<br>
디자인 패턴과 POJO 등은 이론으로 보아선 의미가 없을 것 같아 각자 코드로 직접 타이핑해보며 학습해봅시다.<br>


## 참고문헌

![image](https://user-images.githubusercontent.com/72953874/163352691-165d7730-0f17-41ca-a8c7-57d0b8de1af3.png)

저자 김종민|위키북스 |2015.04.08|
페이지 396|ISBN 9788998139940|